# "Single note storage" contract example

```C
#include "stdlib.fc";

int equal_slices(slice a, slice b) asm "SDEQ";

() store_data(
    slice owner_address,
    cell note
) impure
{
    set_data(
        begin_cell()
            .store_slice(owner_address)
            .store_ref(note)
        .end_cell()
    );
}

_ load_data()
{
    slice ds = get_data().begin_parse();

    return(
        ds~load_msg_addr(), ;; Load owner's address
        ds~load_ref()       ;; Load note
    );
}

cell get_note() method_id
{
    var (_, note) = load_data();

    return note;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body)
{
    if ( in_msg_body.slice_empty?() ) { return (); } ;; Skip empty messages

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { return (); } ;; Skip bounced messages

    slice sender_address = cs~load_msg_addr();

    var ( owner_address, _ ) = load_data();

    throw_unless( 401, equal_slices( sender_address, owner_address ) ); ;; Check if an owner has set a message to a contract

    int op = in_msg_body~load_uint(32); ;; Load opcode
    int query_id = in_msg_body~load_uint(64); ;; Load seqno

    if( op == 1 ) ;; Checking a opcode to be a command to change a note's conent
    {
        cell new_note = in_msg_body~load_ref(); ;; Loading a new note's content
        store_data(
            owner_address,
            new_note
        ); ;; Saving new note's data
        return (); ;; We're done!
    }

    throw( 404 ); ;; Throwing an exception if an opcode does not supported
}
```

This is a note storage contract. It stores your notes in a blockchain. You can edit this and anyone can read it from the contract's data.
It is possible to read it's content, using a get_note method.
You can send a message described in a [contract.cell.ts](code/contract.cell.ts) to a smart contract to change it's content.
But make sure to change an owner's address in a [stateinit.cell.fc](code/stateinit.cell.ts), other-vice, you won't be able to interact with it!

# How does it work
The first part of a contract is filtering out all bounceable and empty messages not to burn too much gas.
```C
if ( in_msg_body.slice_empty?() ) { return (); } ;; Skip empty messages

slice cs = in_msg_full.begin_parse(); ;;
int flags = cs~load_uint(4); ;; Load flags from message

if (flags & 1) { return (); } ;; Skip bounced messages
```

The second part is checking a sender's address to be equal an owner's address stored in a contract's storage.
It uses a `load_data()` function. It loads data from a contract's storage and parses it, reading an owner's address and
note itself.
```C
slice sender_address = cs~load_msg_addr();

var ( owner_address, _ ) = load_data();

throw_unless( 401, equal_slices( sender_address, owner_address ) ); ;; Check if an owner has set a message to a contract
```
`throw_unless( int code, int(bool) condition )` - this function stopping contract execution if condition is false.
`equal_slices( slice a, slice b )` - checks if a's data is equal to b's data.

Then it is reading an operation code (opcode) from a message. If it is equals to 1 - it is a command to change a note's data.
If it so - contract reading new note from a message and saves it into a contract's storage.
```C
int op = in_msg_body~load_uint(32); ;; Load opcode
int query_id = in_msg_body~load_uint(64); ;; Load seqno

if( op == 1 ) ;; Checking a opcode to be a command to change a note's conent
{
    cell new_note = in_msg_body~load_ref(); ;; Loading a new note's content
    store_data(
        owner_address,
        new_note
    ); ;; Saving new note's data
    return (); ;; We're done!
}

throw( 404 ); ;; Throwing an exception if an opcode does not supported
```