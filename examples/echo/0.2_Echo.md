# "Echo" smart contract example
```C
#include "stdlib.fc";

() send_payment(int amount, slice address) impure inline {
    var msg = begin_cell()
            .store_uint(0x10, 6) ;; nobounce
            .store_slice(address)
            .store_grams(amount)
            .store_uint(0, 107)
            .end_cell();

    send_raw_message(msg, 1);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure
{
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    if (flags & 1)
    {
        ;; ignore all bounced messages
        return ();
    }
    slice s_addr = cs~load_msg_addr();
    send_payment( msg_value - 281300200, s_addr );
    return ();
}
```
This smart contract is a basic example of processing incoming internal simple transfer messages and sending them back.

Let's look at recv_internal function first:
It parses an incoming message and looking for "bounced" flag. This flag is being set when smart contract sending
message to other contract that does not exist or if some error happened during the receiving smart contract execution.
If this message is bounced - it will be just ignored.
```C
var cs = in_msg_full.begin_parse(); ;; starting parse of incoming message
var flags = cs~load_uint(4);  ;; reading flags from incoming message.
                              ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
if (flags & 1) ;; is bounced?
{
    ;; ignore all bounced messages
    return ();
}
```

The next step is getting a sender address from incoming message.
`slice s_addr = cs~load_msg_addr();`
Then it subtracts a fee from amount it is going to send.
And uses `send_payment` function to send coins back to sender.

`send_payment` function builds a simple transfer message with cell_builder:
```C
var msg = begin_cell()
              .store_uint(0x10, 6) ;; set bounce flag to zero ( this message is not bounced! )
              .store_slice(address) ;; add address of contract to send coins to
              .store_grams(amount) ;; sadd amount of coins to send ( in nanotons )
                                   ;; 1 TON = 1000000000 NanoTONs
              .store_uint(0, 107) ;; filling the rest of message with 107 zeroes
          .end_cell();
```
Then it uses `send_raw_message` function from FunC STD. It sends message to blockchain.
The first argument of this function is message we want to send. The second if a sending flag.
"0" flag means, that we are sending an ordinary message. More on sending flags you can find in a `1.3.0.0 | Internal messages`